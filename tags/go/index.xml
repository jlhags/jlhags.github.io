<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Theoretically Josh</title><link>https://theoreticallyjosh.com/tags/go/</link><description>Recent content in go on Theoretically Josh</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>jlhags+blog@gmail.com (Joshua Hagofsky)</managingEditor><webMaster>jlhags+blog@gmail.com (Joshua Hagofsky)</webMaster><lastBuildDate>Tue, 07 Feb 2023 13:05:11 -0700</lastBuildDate><atom:link href="https://theoreticallyjosh.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Beginning Programming Lesson 08</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-08/</link><pubDate>Tue, 07 Feb 2023 13:05:11 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-08/</guid><description>Now that we have the basics down, let apply them to something more real, and perhaps the previous concepts covered will become more clear. When I learn a new programming language I generally start with trying to create a program to solve the Tricky Triangle. If you have ever been to Cracker Barrel, you know what it is. It goes by some other names too, but it is usually a triangular piece of wood with holes in it with enough golf tees to fill all but one whole.</description></item><item><title>Beginning Programming Lesson 07</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-07/</link><pubDate>Mon, 16 Jan 2023 11:20:36 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-07/</guid><description>In previous lesson we put all of out code in one file and one package, main. However, aside from very small projects, this won&amp;rsquo;t scale very well, and does make your code very reusable apart from copying and pasting. We have already seen the usefulness of packages through using the fmt and errors packages. So let&amp;rsquo;s look at how to create our own. You can find the code for today&amp;rsquo;s lesson here.</description></item><item><title>Beginning Programming Lesson 06</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-06/</link><pubDate>Wed, 07 Dec 2022 11:20:36 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-06/</guid><description>When I was in college my professor explained recursion as &amp;ldquo;Pretend you already have a function that does what you need to do.&amp;rdquo; The problem with that explanation is, it only makes sense after you understand recursion. I think we can do better here. While we are at it, let&amp;rsquo;s look at error handling too. You can find the code for today&amp;rsquo;s lesson here.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; ) type MinInputError struct { } func (e *MinInputError) Error() string { return &amp;#34;invalid input, number must be greater than 0&amp;#34; } type MaxInputError struct { } func (e *MaxInputError) Error() string { return &amp;#34;invalid input, number must be less than 100&amp;#34; } func Factorial(n int) int { if n == 1 { return n } return n * Factorial(n-1) } func Factorial2(n int) (int, error) { if n &amp;lt; 0 { return 0, &amp;amp;MinInputError{} } if n &amp;gt; 100 { return 0, &amp;amp;MaxInputError{} } ret := n for i := n - 1; i &amp;gt; 0; i-- { ret = ret * i } return ret, nil } func main() { fmt.</description></item><item><title>Beginning Programming Lesson 05</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-05/</link><pubDate>Mon, 28 Nov 2022 07:03:58 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-05/</guid><description>We created complex data types (structs/classes), but what if we wanted to create another struct that expands upon another? Or you wanted to create a number of different structs that play by a certain set of rules. The example code for today can be found here.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Polygon interface { Shape() string Perimeter() float64 Area() float64 } type Rectangle struct { Length float64 Height float64 } func (r Rectangle) Perimeter() float64 { return 2*r.</description></item><item><title>Beginning Programming Lesson 04</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-04/</link><pubDate>Mon, 14 Nov 2022 11:13:23 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-04/</guid><description>We now know how to create and use variables, structs, and functions. But thus far, all the examples have been fairly linear. What if we want do things only when certain criteria are met? Or what if we want to do the same thing many times in a row? What if we want want store a bunch of a rectangles from the previous lesson? This is where control structures, arrays and slices come in handy.</description></item><item><title>Beginning Programming Lesson 03</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-03/</link><pubDate>Tue, 08 Nov 2022 09:03:18 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-03/</guid><description>In the last installment of this series we learned about variables, and covered some simple variable types. Now we are going to learn about complex data types. In short, they store more than a single data point of information. For example, what if we wanted to have a variable that stored information about a rectangle? There is more than one bit of information to describe it. At minimum you would probably want to store its width and length.</description></item><item><title>Beginning Programming Lesson 02</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-02/</link><pubDate>Tue, 01 Nov 2022 09:22:40 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-02/</guid><description>Now that you have your setup ready to go, we can start writing some code! Note that we are just touching the surface of the topics covered in this lesson, but the sooner you start writing code, the easier it will become to understand the topics better. Plus you are more likely to continue, if you feel like you are accomplishing something, rather than learning more and more theory. You can download the file here.</description></item><item><title>Beginning Programming Lesson 01</title><link>https://theoreticallyjosh.com/post/beginning-programming-lesson-01/</link><pubDate>Fri, 28 Oct 2022 09:15:05 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lesson-01/</guid><description>When I was about 12 years old, my aunt gave us an old computer. Without going into all the details, I broke it, and all that it would then let you do is write programs in BASIC. It came with a book explaining how to do various things with the language. So having nothing better to do, I worked through it and taught myself how to code, and eventually went to college to learn how to do it better.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>interfaces on Theoretically Josh</title><link>https://theoreticallyjosh.com/tags/interfaces/</link><description>Recent content in interfaces on Theoretically Josh</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>jlhags+blog@gmail.com (Joshua Hagofsky)</managingEditor><webMaster>jlhags+blog@gmail.com (Joshua Hagofsky)</webMaster><lastBuildDate>Mon, 28 Nov 2022 07:03:58 -0700</lastBuildDate><atom:link href="https://theoreticallyjosh.com/tags/interfaces/index.xml" rel="self" type="application/rss+xml"/><item><title>Beginning Programming Lession 05</title><link>https://theoreticallyjosh.com/post/beginning-programming-lession-05/</link><pubDate>Mon, 28 Nov 2022 07:03:58 -0700</pubDate><author>jlhags+blog@gmail.com (Joshua Hagofsky)</author><guid>https://theoreticallyjosh.com/post/beginning-programming-lession-05/</guid><description>We created complex data types (structs/classes), but what if we wanted to create another struct that expands upon another? Or you wanted to create a number of different structs that play by a certain set of rules. The example code for today can be found here.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Polygon interface { Shape() string Perimeter() float64 Area() float64 } type Rectangle struct { Length float64 Height float64 } func (r Rectangle) Perimeter() float64 { return 2*r.</description></item></channel></rss>